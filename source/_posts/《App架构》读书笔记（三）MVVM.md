---
title: 《App架构》读书笔记（三）MVVM
date: 2018-12-03 15:03:02
tags: iOS开发
---

# 4.Model-View-ViewModel

>Model-View-ViewModel(MVVM)是一种基于MVC进行改进的模式，它将所有model相关的任务(包括更新model，观察变更，将model变形为可以显示的形式等)从controller层抽离出来，放到新的叫做view-model的一层对象中。在通常的iOS实现中，view-model位于model和controller之间:

![1](1.png)

>MVVM所做的不仅仅是把代码移动到新的地方。加入一层新的view-model层的目的是双重的:
>
>1. 鼓励将model和view之间的关系构建为一系列的变形管道。
>2. 提供一套独立于app框架的接口，但是它在相当程度上代表了view应该展示的状态。
>
>---
>为了保持view与view-model的同步，MVVM强制使用某种形式的绑定，也就是说，需要一种保证一个对象上的属性与另一个对象上的属性同步的方式。Controller负责构建这些绑定，将view-model所暴露的属性和场景中view-model所代表的view 上的属性关联起来。

**View-Model**: Model是是对app的抽象，是一个没有UI的app；view-model顾名思义，是对view的抽象，是一个没有具象化的view。为了将代码分层，我们多引入了一层，随之而来的代价是需要更多的接口去与各层之间交流，同步状态，所以MVVM一般都使用某种绑定(例如`RxSwift`)去减少这种代价。

原文中还引入了协调器的概念，这种架构也有一定可取之处，但我在这里只想讨论MVVM的事。

## 构建

>MVVM构建的方式和MVC的模式很相似: controller层充分了解程序的结构，它使用这些认知来对所有部件进行构建和连接。相比起MVC，主要有三个不同:
>
1. 必须创建view-model。
2. 必须建立起view-model和view之间的绑定。
3. Model由view-model拥有，而不是由controller所拥有。

1框图真的非常重要，尽管它看起来如此简单，但是只有理解了框图，才能明白自己应该如何写MVVM代码。

由于view的交互事件到达controller之后，会直接交给view-model处理，所以view controller的代码会大幅减少；而处理model之后的结果，会通过之前写好的响应式变形管道自动触发更新view，也就是所有的右边的箭头，都是通过事先绑定，之后自动触发的，这就是**数据驱动**，会让代码非常健壮、简洁和便于查找问题。

## 讨论

>初步印象来说，因为MVVM加入了额外的一层来进行管理，看起来是比MVC模式更加复杂。不过，在实现的层级，如果你能够始终如一地贯彻这个模式，代码会变得更简单一些。

---
>啊，这里说的简单并不意味着容易，只有当你对常⻅的响应式代码变形熟悉以后，才不会对书写代码感到无从下手，才不会对调试问题感到懊恼沮丧。不过，从令人高兴的一面来说，精心设计的数据管道通常不容易产生错误，在⻓期来看维护也更容易一些。

---
>MVVM通过将model观察的代码以及其他显示和交互逻辑移动到围绕着数据流构建的隔离的类中，解决了MVC controller里不规则的状态交互所带来的有关问题。因为这是MVC中最显著的问题，而且会随着controller的增大而恶化，这个变化在很大程度上缓解了MVC中controller肥大的问题。但是还有其他一些因素会使得controller(以及view-model)变大， 所以为了可持续发展，重构依然还是有需要的。

---
>MVC 中另一个常⻅问题是，由于观察者模式没有被严格执行，所导致的model和view之间不同步。View-model属性和view属性之间的响应式绑定解决了这个问题。绑定之所以能解决这个问题，是因为view上初始值的设定和它们接下来的更新都经由统一的代码路径完成。

---
>不过引入响应式编程也不是没有缺点的: 响应式编程框架有着陡峭的学习曲线，而且你需要花上一段时间才能调整到这种编程⻛格。虽然响应式编程在概念上来说十分优雅，但是由于响应式编程框架依赖高度抽象的变形以及大量的类型，对它们的误用可能导致你的代码无法被人类理解。

上面这一段话非常的精炼，基本上解读了MVVM和MVC的所有问题。

就我自己的感受而言，千万不要觉得响应式编程是难学也难懂的，甚至对它产生贬低的情绪。响应式编程的确要求你有一个较好的基础，在对MVC架构和Apple的架构技术框架(`delegate`、`Notification`、`KVO`等)非常熟练之后，才会开始期望有一些抽象的，快捷的方式去完成以前做的那些关于触发更新、触发事件而写的大量的代码，并且取了很多的名字。用过响应式编程后，才能体会到那其实就是对以前的各种操作的封装，并且匿名了（因为都是通过统一的接口subscribe），还把设置初始值和后续更新的路径也统一了。响应式编程非常的棒，并且我认为是编程趋势。

如果真的想要了解MVVM：

- 应该先去学习响应式编程(`RAC`,`RxSwift`)，然后就会知道什么是变形管道，如何把初始值的设定和接下来的更新都由统一的代码路径完成。
- 在有了响应式编程的基础后，再来思考MVVM的分层逻辑，牢记1框图，就能明白各个层之间应该如何传递信息。
- 至于其他的部分，完全和MVC一样，MVC能做的改进，MVVM也可以做。

当理解透彻之后，写代码的时候不必再流于框架的形式，完全可以自由发挥，但是一定要记得这些框架的核心思想以及单向数据流的思考，这样写出来的代码才不至于杂乱无章。

如果依然感到无处下笔的话，可以多看看本书附带的代码。

## 数据变形

>从MVVM可以学到的另一点是，将数据变形逻辑从controller中抽离出来是很有好处的。MVC中controller层的一个职责就是将model数据变形为所配置的view中所需要的显示数据。通常这意味着将model对象上的字符串，数字或者日期转变为可以显示的形式。即使在最简单的情况下，将这边部分代码抽离出来，也可以让controller更加整洁，同时易于测试。

---
>在比简单的格式化操作更复杂的情况下，数据变形可能会牵涉到更多的逻辑，这时抽离的好处就会相当明显。比如，当你的 view依赖于model中被变更的内容时，你可能需要将新的数据与老的数据进行比较，或者将若干个model对象的数据进行整合并显示。如果能将这些操作从其他用于view管理的代码中分离出来的话，它们会更加清晰。

View-Model是从controller层再次抽离一层出来的思想，说到底其实是一种controller层的改进，但是由于这种改进非常有用，以及响应式编程在这里的完美发挥，MVVM才会如此知名。
