---
title: 《App架构》读书笔记（一）介绍
date: 2018-11-30 17:05:04
tags: 
---

# [《App架构》书籍地址](https://objccn.io/products/app-architecture)

[objc](https://www.objc.io)真的是非常棒的网站，上面有很多高质量的文章，非常适合学习和反复学习。以及它的中国翻译版本[objccn](https://objccn.io)，正如它所说**为中国 Apple 开发社区带来最佳实践和先进技术**。

近期读了objccn出品的《App架构》(《App Architecture》的翻译版本)，觉得收获很大。其中特别有帮助的章节是关于MVC、MVVM架构和关于网络层的讨论，其次是关于*view state*的思考，剩下的内容可能不太有用，但书中也做了介绍，并且表明了原意，“希望多参考别的框架，然后能带来一些启发”。总之，我特别想对书中内容进行归纳和整理，以供自己思考。

《App架构》电子书需要的话可以给我留言或者发邮件

## 关于架构自己的一些思考

在讲架构之前，我们可以考虑一下关于跨平台开发的思考。很久以前我会觉得语法是最大的问题，假设一开始app是iOS的，只要做一套Android版本的语法翻译或者类似实现，然后好像就没什么问题了。

后来我学习了一些其他语言，发现语法问题真的影响很小:

- 先说说学习的时间成本问题，一种新语言的语法我用比较慢的速度学习，也仅仅需要两周时间就能掌握了，甚至更少.（这不包括一些额外的框架的学习时间，比如学习objective-c，仅仅是语法，不包括UIKit等框架的学习。）
- 另外不同的语法之间自动转换接口，在未来应该也是可以预见的。（比如现在objective-c和Swift之间就能桥接，互相提供准确的接口。）

其次，假设真的Android版本实现了，只要稍微想想就能知道，其中重复意义的代码是非常多的。比如两个app都设置了完全相同的Model，完全相同的请求网络数据的逻辑，可以说在数据显示在屏幕之前，大部分的逻辑都是重复的。

真正的不同之处，是自身系统对特定操作做的库，比如不同的UI框架、媒体处理框架等，因为使用这些框架的时候，通常为了实现一个效果，也可能使用完全不同的逻辑。

所以如果在使用这些特定框架之前，能够细心地设计接口，把之前的那些逻辑完全解耦出来，达到可以放心的交给机器自动翻译的程度，然后在针对各个平台的特性，去完成需要使用特定框架完成的逻辑。这样的跨平台产品，最大程度的复用了代码或者说app逻辑，同时具备自身平台的特性。

---

App的本质是一个反馈回路，程序启动、界面展示、用户交互、数据处理、重新展示到界面。架构就是关于这一系列流程的思考，在书写代码上会体现成一种写法规范，只有真正了解了架构的意义，才能去完整的遵守这种规范，因为代码的自由度是非常高的，能最终实现需求的代码，答案是很有多种的，也正是这种原因，代码的质量有高有低，也引发了我们的思考，如何设计更加健壮的代码。

在一个良好的架构面前，很多不太好处理的问题会变得极其简单，比如说:

- 换皮肤。因为view层是完全解耦的，只需要重新设计新的view层，然后连接接口即可。
- 在没有网络时展示上次缓存的数据。因为model层能够控制缓存和刷新机制，而view层的展示完全基于model层的数据。
- 使用单向数据流的方式，让app保持状态一致，统一UI的更新路径，避免冗余代码。

我只是随便列举了几个，优点不再赘述了。

# 1.介绍

回到书里的章节开始，作为iOS开发者，我们最先接触的都是苹果的MVC框架，也是一直以来大部分人所使用的。

![1](1.png)

1框图表达的逻辑很清晰:

1. view接收到用户的交互事件
2. controller处理
3. 修改model
4. 再由controller获取到被修改后的model信息
5. 更新view，反馈给用户

但其实在实际开发中，很少有人能严格遵守规则，第4步通常会被略过，而第3步在修改model之后，同时就直接去更改了view，也是这个原因，有时候会造成数据与UI不同步的bug。

究其原因，我认为是MVC真正的意义并没有被得到透彻的理解

## Model和View

**Model**: model层是app的内容，是对app的抽象，完整的model层应该能完全代表一个没有界面的app。它是完全解耦的，阻止model层跨平台的唯一障碍应该是语言的语法问题。除此之外，根据书中的定义，能被存储在磁盘里的model被叫做*文档model*。

**View**: view层是依赖app框架的部分，它让model层变得可见，允许用户交互。iOS里通常使用UIKit，也可能使用SceneKit或者OpenGL，它是需要根据系统平台来书写不同实现路径的代码的。

## App的本质是反馈回路

![2](2.png)

- 2框图显示了view和model之间的交流，view发出交互事件，叫*view action*。
- 比如点击按钮，送到model的时候，model层可能需要删除某个数据，叫做*model action*。
- 修改完毕之后，会触发*model通知*，在对应的view收到通知后，会根据model的内容做*view变更*，这样一次交互反馈就完成了。这里的通知并不只是代表`Notification`，而是一切可以触发代码消息的框架技术。
- 但这并不完全，有些状态其实没有被保存在model里，比如一个table view的content offset或者导航栈的位置，这些状态叫做*view state*，它们通常被存储在view层，由view对象各自的属性维持，有些架构会把*view state*放到model层，有时候为了方便的实现某种需求，我也会把某些暂存在model里，比如像isSelected这样的选中状态。

如果app的逻辑真的像2框图一样，路径如此的清晰和规范，书中称它们为*单向数据流*。当任意的view对象或者中间层对象只能够通过model发出的通知来进行创建和更新 (换句话说，view 或者中间层不能通过捷径来更新自身或者其他的 view) 时，这个模式通常就是单项的。这是一种理想状态，稍微有经验的开发者能够体会到，这是非常好的模式，代码会变得非常健壮，因为view和model的状态一定是同步的，这能避免很多bug产生。

## 架构技术

关于model通知的发出，可以使Apple的`Notification`或者`KVO`，但这些工具十分有限，有些开发者会对这些工具进行封装，使其变得更好用，但其实不如使用一些第三方工具，使用响应式编程，比如`RAC`或者`RxSwift`，它们专注于在源和目标之间进行变形，让逻辑可以在部件之间传输信息的同时得以表达。